#pragma kernel Setup
#pragma kernel Update
#pragma kernel Apply

#define THREAD [numthreads(8, 1, 1)]
#define DISCARD if(id.x > (uint)_InstancesCount) return;

#ifndef PI
#define PI 3.14159265359
#endif

#include "../../../Shaders/Common/Random.cginc"
#include "../../../Shaders/Common/Matrix.cginc"
#include "../../../Shaders/Common/Quaternion.cginc"
// #include "../../../Shaders/Common/Noise/SimplexNoise3D.cginc"
#include "../../../Shaders/Common/Noise/SimplexNoiseGrad3D.cginc"
#include "../../../Shaders/Common/ProcSkinAnim.cginc"
#include "../Common/Trail.cginc"

int _InstancesCount;
RWStructuredBuffer<GPUBone> _Bones;
RWStructuredBuffer<GPUTrail> _Trails;

int _BonesCount;
float _BonesCountInv;

float4x4 _BindMatrix, _BindMatrixInv;
float4x4 _WorldToLocal, _LocalToWorld;

float3 _Max, _Min, _Center;
float _UnitLength;

float4 _Time;
float2 _DT;

float3 _NoiseOffset, _NoiseParams;
half2 _Damper;

half3 _Gravity;

GPUTrail Create(int i)
{
    GPUTrail tr;
    tr.position = float3(_Center.x, _Max.y - _UnitLength * i, _Center.z);
    tr.velocity = float3(0, 0, 0);
    tr.normal = float3(0, 0, 1);
    tr.tangent = float3(0, 1, 0);
    tr.binormal = float3(1, 0, 0);
    return tr;
}

THREAD
void Setup (uint3 id : SV_DispatchThreadID)
{
    DISCARD

    int index = id.x * _BonesCount;

    float3 offset = random_point_on_sphere(id.xy) * 10;

    for (int i = 0; i < _BonesCount; i++) {
        GPUTrail tr = Create(i);
        tr.position += offset;
        _Trails[index + i] = tr;
    }
}

/*

// Divergence-free noise field
float3 NoiseField(uint id, float3 p)
{
    p += float3(0.9, 1.0, 1.1) * (10.0 * id);
    float3 n1 = snoise(p).xyz;
    float3 n2 = snoise(p + float3(15.3, 13.1, 17.4)).xyz;
    return cross(n1, n2);
}

void Floating(int index)
{
    float3 p_prev = _Trails[index].position.xyz;
    int i;
    for (i = 1; i < _BonesCount; i++)
    {
        float3 np = (p_prev + _NoiseOffset) * 0.5;
        float3 v = NoiseField(index, np) * 0.5;
        float3 p_update = p_prev + v * _DT.x;

        p_prev = _Trails[index + i].position.xyz;
        _Trails[index + i].position.xyz = p_update;
    }

    // Retrieve the previous position and velocity.
    GPUTrail head = _Trails[index];
    float3 p = head.position.xyz;
    float3 v = head.velocity.xyz;

    // Force from the attactor.

    // Force from the noise field.
    float3 np = (p + _NoiseOffset) * 0.5;
    float3 f_n = NoiseField(index, np) * 0.5;

    // Apply drag and acceleration force.
    v = v * _Damper.x + (f_n) * _DT.x;

    // Update the head position.
    p += v * _DT.x;

    head.position.xyz = p;
    head.velocity.xyz = v;
    _Trails[index] = head;
}
*/

void Sequence(int index)
{
    // Floating(index);

    int i;
    for (i = 1; i < _BonesCount; i++)
    {
        GPUTrail parent = _Trails[index + i - 1];
        GPUTrail child = _Trails[index + i];

        float3 dir = parent.position - child.position;
        float l = length(dir);
        child.position = lerp(child.position, child.position + step(_UnitLength, l) * dir, _DT.x);

        _Trails[index + i] = child;
    }

    GPUTrail head = _Trails[index];
    float3 p0 = head.position.xyz;
    float3 p1 = _Trails[index + 1].position.xyz;

    float3 t0 = normalize(p0 - p1);
    float3 b0 = cross(t0, normalize(p0));
    float3 n0 = cross(b0, t0);

    head.normal = n0;
    head.tangent = t0;
    head.binormal = b0;
    _Trails[index] = head;

    for (i = 1; i < _BonesCount - 1; i++)
    {
        p0 = _Trails[index + i - 1].position.xyz;
        float3 p2 = _Trails[index + i + 1].position.xyz;

        float3 t1 = normalize(p2 - p0);
        float3 n1 = normalize(cross(b0, t1));

        GPUTrail cur = _Trails[index + i];
        cur.normal = n1;
        cur.tangent = t1;
        cur.binormal = b0;
        _Trails[index + i] = cur;

        b0 = normalize(cross(t1, n1));
    }

    GPUTrail tail = _Trails[index + _BonesCount - 1];

    p0 = _Trails[index + _BonesCount - 2].position.xyz;
    p1 = tail.position.xyz;

    float3 t1 = normalize(p1 - p0);
    float3 n1 = normalize(cross(b0, t1));

    tail.normal = n1;
    tail.tangent = t1;
    tail.binormal = b0;

    _Trails[index + _BonesCount - 1] = tail;
}

THREAD
void Update (uint3 id : SV_DispatchThreadID)
{
    DISCARD

    int index = id.x * _BonesCount;

    GPUTrail head = _Trails[index];

    float3 v = head.velocity;
    // Drag and acceleration.
    v.xyz = v.xyz * _Damper.x + _Gravity.xyz;

    float3 seed = head.position.xyz;
    float3 np = (seed + _NoiseOffset) * _NoiseParams.x;
    float3 n1 = snoise_grad(np);
    float3 n2 = snoise_grad(np + float3(21.83, 13.28, 7.32));
    v.xyz += cross(n1, n2) * _NoiseParams.y;
    // v = float3(0, 0.1, 0);

    head.velocity = v;

    // Apply the velocity cap.
    float lv = max(length(v.xyz), 1e-6);
    v.xyz = v.xyz * min(lv, _Damper.y) / lv;

    // Update the position with the velocity.
    head.position.xyz += v.xyz * _DT.x;

    _Trails[index] = head;

    Sequence(index);
}

float4x4 MakeRotationMatrix(GPUTrail tr)
{
    return axis_matrix(normalize(tr.binormal), normalize(tr.tangent), normalize(tr.normal));
}

THREAD
void Apply (uint3 id : SV_DispatchThreadID)
{
    DISCARD

    float4x4 moffset = _LocalToWorld;
    int ioffset = id.x * _BonesCount;

    for (int i = 0; i < _BonesCount; i++) {
        int index = ioffset + i;
        GPUBone bone = _Bones[index];
        GPUTrail tr = _Trails[index];

        // copy position and rotation from GPUTrail

        // global to local
        // float3 local = mul(inverse(moffset), mul(_LocalToWorld, float4(tr.position, 1))).xyz;
        // local = mul(inverse(bone.local), float4(local.xyz, 1)).xyz;

        // float4x4 conv = mul(mul(_LocalToWorld, inverse(moffset)), inverse(bone.local));
        float4x4 conv = mul(mul(inverse(bone.local), inverse(moffset)), _LocalToWorld);

        float3 translation = mul(conv, float4(tr.position.xyz, 1)).xyz;
        // float4x4 rotation = mul(conv, axis_matrix(tr.binormal, tr.tangent, tr.normal));
        float4x4 rotation = mul(conv, MakeRotationMatrix(tr));
        // float4x4 rotation = mul(conv, axis_matrix(float3(1, 0, 0), float3(0, 1, 0), float3(0, 0, 1)));

        bone.position = translation;
        bone.rotation = extract_rotation_matrix(rotation);

        _Bones[index] = bone;

        float4x4 diff = GetBoneMatrix(bone);
        moffset = mul(moffset, mul(diff, bone.local));
    }

}

